# 7.7 Наращивание тестовой базы и рефакторинг
[назад](../readme.md)

Содержание:
- [Рефакторинг папки pages](#новая-структура-папки-pages)
- [Рефакторинг папки tests](#новая-структура-папки-tests)
- [Рефакторинг фикстуры initialize_browser_state](#рефакторинг-фикстуры-initialize_browser_state)
- [Использование тестовых классов](#использование-тестовых-классов)
- [Автоматическое добавление флагов в pytest](#автоматическое-добавление-флагов-в-pytest)
- [Добавление автотеста test_successful_authorization](#добавление-автотеста-test_successful_authorization)
- [Добавление автотеста test_navigate_from_authorization_to_registration](#добавление-автотеста-test_navigate_from_authorization_to_registration)
- [Практикуемся в написании автотестов с использованием Page Object, Page Component, Page Factory (домашняя работа)](#практикуемся-в-написании-автотестов-с-использованием-page-object-page-component-page-factory-домашняя-работа)



## Рефакторинг папки pages
### Новая структура папки pages
Разделим страницы по соответствующим функциональным областям приложения.  
Для этого создадим подкаталоги и перенесем в них страницы:
```text
.
└── pages/
    ├── __init__.py
    ├── base_page.py
    ├── courses/
    │   ├── __init__.py
    │   ├── courses_list_page.py
    │   └── create_course_page.py
    ├── dashboard/
    │   ├── __init__.py
    │   └── dashboard_page.py
    └── authentication/
        ├── __init__.py
        ├── login_page.py
        └── registration_page.py
```

### Объяснение изменений:
- Папка **courses**: Страницы, связанные с курсами, такие как список курсов и создание курса, теперь находятся в одной директории.
- Папка **dashboard**: Страница с дашбордом перемещена в отдельную папку, так как она имеет свой специфический функционал.
- Папка **authentication**: Страницы для аутентификации, такие как логин и регистрация, теперь сгруппированы в папке *authentication*.

### Рекомендации по группировке страниц:
Чтобы правильно организовать страницы в большом приложении:
1. Исследуйте приложение: Пройдитесь по всем страницам приложения и определите, какие основные группы страниц существуют.
2. Группируйте по функционалу: Например, страницы для чатов, профилей пользователей, курсов, настроек и так далее могут быть размещены в отдельных папках.
3. Используйте логичные названия: Названия папок и файлов должны четко отражать назначение содержимого. Это упростит понимание структуры проекта как для вас, так и для других разработчиков.

[вверх](#77-наращивание-тестовой-базы-и-рефакторинг)


## Рефакторинг папки tests

### Новая структура папки tests

Для улучшения порядка мы можем разделить тесты на папки в зависимости от их функциональности.  
В итоге структура будет выглядеть так:
```text
.
└── tests/
    ├── pytest/
    │   ├── test_pytest.py
    │   ├── test_reruns.py
    │   ├── test_fixtures.py
    │   ├── test_pytest_skip.py
    │   ├── test_pytest_xfail.py
    │   ├── test_pytest_skipif.py
    │   └── test_parametrization.py
    ├── courses/
    │   └── test_courses.py
    ├── dashboard/
    │   └── test_dashboard.py
    └── authentication/
        ├── test_registration.py
        └── test_authorization.py
```

### Объяснение изменений:
- Папка **pytest/**: Все тесты, связанные с изучением фреймворка *pytest*, сгруппированы вместе.
- Папка **courses/**: Здесь находятся тесты, которые проверяют функциональность, связанную с курсами.
- Папка **dashboard/**: Тесты, которые проверяют элементы и функциональность дашборда, собраны в этой папке.
- Папка **authentication/**: Тесты, проверяющие функционал регистрации и авторизации, сгруппированы в этой папке.

### Общие рекомендации:
1. Группировка по функциональности: Тесты следует организовывать в папки по проверяемым функциональным областям, а не только по страницам. Это позволяет лучше структурировать тесты и не привязываться к изменениям в интерфейсе.
2. Масштабируемость: В больших проектах правильная структура тестов упрощает работу с ними и делает проект более масштабируемым. Например, в случае добавления новых функциональностей достаточно создать новую папку с тестами для этой функции, не изменяя существующую структуру.
3. Гибкость в подходах: Не всегда стоит следовать строгому соответствию страниц и тестов. Функциональные области могут пересекаться между различными страницами, но это не должно мешать грамотному структурированию тестов по функциональности.

[вверх](#77-наращивание-тестовой-базы-и-рефакторинг)


## Рефакторинг фикстуры initialize_browser_state

Мы используем *RegistrationPage* для более читабельной работы с регистрационной формой

[вверх](#77-наращивание-тестовой-базы-и-рефакторинг)


## Использование тестовых классов

Ранее мы использовали тестовые функции для написания автотестов, а теперь перейдем на тестовые классы. Тестовые классы являются рекомендуемым подходом в *pytest*.  

### Преимущества тестовых классов
1. **Централизованное применение маркировок**: как видно из примера, маркировку можно указать один раз для всего класса.
2. **Меньше повторяющегося кода**: при параметризации, вместо дублирования параметров для каждой функции, параметризация указывается один раз для класса.

### Рефакторинг существующих автотестов
**Изменения:**  
1. Маркировки теперь указаны на уровне класса, а не функции.
2. Тестовые функции преобразованы в методы (появился аргумент *self*).

[вверх](#77-наращивание-тестовой-базы-и-рефакторинг)


## Автоматическое добавление флагов в pytest

Ссылки:
 - [Официальная документация Pytest по добавлению флагов к команде запуска тестов](https://docs.pytest.org/en/stable/example/simple.html#how-to-change-command-line-options-defaults)

При каждом запуске автотестов часто приходится вручную добавлять флаги *-s* и *-v*, чтобы видеть подробный вывод в консоли. Это не всегда удобно, особенно если эти флаги нужны постоянно. К счастью, в pytest есть возможность сделать добавление таких флагов автоматическим для всех запусков.

Для этого можно добавить опцию addopts в файл *pytest.ini*. Пример настройки:
```ini
[pytest]
addopts = -s -v # Опция для автоматического добавления флагов
python_files = *_tests.py test_*.py
python_classes = Test*
python_functions = test_*
markers =
    courses: Маркировка для тестов, связанных с курсами.
    dashboard: Маркировка для тестов, связанных с рабочей панелью.
    regression: Маркировка для регрессионных тестов.
    registration: Маркировка для тестов, связанных с регистрацией пользователей.
    authorization: Маркировка для тестов, связанных с авторизацией пользователей.
```

### Зачем это нужно?
1. **Экономия времени**: вам не нужно каждый раз прописывать одни и те же аргументы.
2. **Единообразие**: все разработчики в команде будут запускать тесты с одинаковыми параметрами, что минимизирует разночтения и недоразумения.
3. **Гибкость**: если в будущем потребуется добавить другие аргументы или флаги, это можно сделать централизованно в одном месте.

[вверх](#77-наращивание-тестовой-базы-и-рефакторинг)


## Добавление автотеста *test_successful_authorization*

Ссылки:
- [E2E тестирование](https://circleci.com/blog/what-is-end-to-end-testing/)

### Описание теста
По названию автотеста test_successful_authorization становится ясно, что он будет проверять успешную авторизацию в приложении. Полный тест-кейс выглядит так:
1. Открываем страницу регистрации: https://nikita-filonov.github.io/qa-automation-engineer-ui-course/#/auth/registration.
2. Заполняем форму регистрации валидными данными и нажимаем кнопку "Registration".
3. Происходит редирект на страницу "Dashboard": https://nikita-filonov.github.io/qa-automation-engineer-ui-course/#/dashboard. Нажимаем кнопку "Logout" в Sidebar, происходит редирект на страницу "Login".
4. Заполняем форму авторизации валидными данными и нажимаем кнопку "Login".
5. Проверяем, что происходит редирект обратно на страницу "Dashboard": https://nikita-filonov.github.io/qa-automation-engineer-ui-course/#/dashboard.

**E2E тестирование**: Это полный тест-кейс, который покрывает регистрацию, логаут и авторизацию, подтверждая, что приложение работает корректно с точки зрения конечного пользователя

В файле *tests/authentication/test_authorization.py* создадим тестовый метод класса *TestAuthorization*:
```python
def test_successful_authorization(self):
    pass

```

[вверх](#77-наращивание-тестовой-базы-и-рефакторинг)


## Добавление автотеста *test_navigate_from_authorization_to_registration*

Этот автотест проверяет простую навигацию со страницы авторизации https://nikita-filonov.github.io/qa-automation-engineer-ui-course/#/auth/login на страницу регистрации https://nikita-filonov.github.io/qa-automation-engineer-ui-course/#/auth/registration. Мы будем проверять, что при нажатии на ссылку "Registration" пользователь будет перенаправлен на правильную страницу.

### Шаги автотеста:
1. Открываем страницу авторизации: https://nikita-filonov.github.io/qa-automation-engineer-ui-course/#/auth/login
2. Нажимаем на ссылку "Registration".
3. Проверяем, что открылась страница регистрации: https://nikita-filonov.github.io/qa-automation-engineer-ui-course/#/auth/registration.

В файле *tests/authentication/test_authorization.py* добавим тестовый метод класса *TestAuthorization*
```python
def test_navigate_from_authorization_to_registration(self):
    pass
```
[вверх](#77-наращивание-тестовой-базы-и-рефакторинг)


## Практикуемся в написании автотестов с использованием Page Object, Page Component, Page Factory (домашняя работа)
[ссылка на описание домашней работы](./homework.md)

[вверх](#77-наращивание-тестовой-базы-и-рефакторинг)