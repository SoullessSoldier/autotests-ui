# 9.5 Логирование взаимодействий со страницей
[назад](../readme.md)


Содержание:
- [Основы логирования в python](#основы-логирования-в-python)
- [Создание собственного логгера и использование его в автотестах](#создание-собственного-логгера-и-использование-его-в-автотестах)
- [Практика работы с логированием](#практика-работы-с-логированием)


## Основы логирования в python

Ссылки:
- [Официальная документация python по logging](https://docs.python.org/3/library/logging.html)

### Что такое логирование?
Логирование — это процесс записи информации о выполнении программного кода в специальный файл или консоль. Эти записи, называемые логами, позволяют разработчикам и администраторам отслеживать поведение приложения, находить и устранять ошибки, а также собирать статистику о его работе. Логирование помогает понять, что происходило в программе в момент её работы, и служит важным инструментом для анализа производительности и выявления проблем.

### Основы логирования в Python.
В Python для логирования используется встроенный модуль *logging*. Он предоставляет гибкий фреймворк для настройки логирования, включая различные уровни важности сообщений и форматы их представления.

#### Уровни логирования

Модуль *logging* поддерживает несколько уровней логирования, что позволяет классифицировать важность сообщений:
1. **DEBUG**: детальная информация, используемая для диагностики проблем. Применяется в процессе разработки.
2. **INFO**: сообщения, которые подтверждают, что всё работает как ожидается.
3. **WARNING**: предупреждения о потенциальных проблемах или неблагоприятных ситуациях, которые не являются критическими.
4. **ERROR**: ошибки, которые произошли в процессе выполнения программы. Они могут вызвать проблемы, но программа продолжает работать.
5. **CRITICAL**: критические ошибки, которые могут привести к остановке программы.

#### Основные компоненты логирования
1. **Логгер (Logger)**: основной интерфейс для создания логов. Он позволяет генерировать записи с различными уровнями важности.
2. **Обработчик (Handler)**: компонент, который определяет, куда будут отправляться сообщения (например, в файл, на консоль или в сеть).
3. **Форматтер (Formatter)**: задаёт формат записи логов, включая дату, уровень важности и само сообщение.

### Применение логирования в автотестах
Логирование в автотестах помогает:
1. **Отслеживать выполнение тестов**: позволяет видеть, какие тесты прошли успешно, а какие — нет, и по каким причинам. Это особенно полезно, когда вы запускаете автотесты локально и хотите отслеживать детали выполнения в консоли.
2. **Диагностировать проблемы**: при сбое теста логирование помогает быстрее выявить причину ошибки.
3. **Собирать статистику**: анализ времени выполнения тестов позволяет выявлять медленные или нестабильные части кода, которые могут нуждаться в оптимизации.

### Основные правила логирования:
- **Логи должны быть краткими и информативными**. Нет смысла записывать длинные сообщения, которые сложно будет анализировать. Логи должны быть полезны, а не перегружены лишней информацией.
- **Избегайте избыточного логирования**. Логируйте только ключевую информацию, которая действительно необходима для понимания выполнения теста.
- **Пример хорошего логирования**
```python
def get_locator(self, nth: int = 0, **kwargs) -> Locator:
    locator = self.locator.format(**kwargs)
    with allure.step(f'Getting locator with "data-testid={locator}" at index "{nth}"'):
        logger.info(f'Getting locator with "data-testid={locator}" at index "{nth}"')
        return self.page.get_by_test_id(locator).nth(nth)

```
В этом примере в логах записывается только нужная информация, что делает их более полезными и удобными для анализа.

[вверх](#95-логирование-взаимодействий-со-страницей)


## Создание собственного логгера и использование его в автотестах

Давайте создадим собственный логгер и добавим логирование в автотесты, особенно на уровне работы с элементами Page Factory, куда мы добавляли Allure шаги.

### 1. Создаем функцию get_logger
Для начала создадим файл *tools/logger.py*:
```
.
└── tools/
    └── logger.py
```
В файле logger.py добавим функцию *get_logger*.

Данная функция отвечает за инициализацию и настройку логгера в нашем проекте. Использовать ее очень просто:
```python
logger = get_logger("INPUT")
logger.info('Typing to input')
logger.info('Clicking input')
```
Вывод в консоль будет соответствовать:
```text
2024-10-27 15:19:14,343 | INPUT | INFO | Typing to input
2024-10-27 15:19:14,343 | INPUT | INFO | Clicking input
```

Реализация таких функций по инициализации и настройке логгера является распространенной практикой, которая позволяет избежать дублирования кода, настраивая логгер, обработчик и форматтер всего один раз. Обратите внимание, что функция принимает name, которое обычно совпадает с названием файла/класса или логическим предназначением файла/класса, где происходит логирование.

### 2. Используем get_logger в элементах Page Factory

Теперь давайте посмотрим, как использовать логгер в автотестах. Начнем с добавления логирования в файл *elements/base_element.py*, где происходят все базовые взаимодействия с элементами на странице.

Теперь давайте взглянем на отчет Allure. На скриншоте ниже видно, что логи, написанные в консоль, автоматически прикреплены к отчету Allure. Это возможно благодаря библиотеке allure-pytest, которая автоматически добавляет все логи в отчет. Это позволяет быстро проанализировать ход автотеста, и эта информация может быть очень полезна для разборов тестов, так как Playwright Trace Viewer не предоставляет данных о взаимодействиях, не связанных напрямую с элементами на странице, например, отправке запросов на сервер.

[вверх](#95-логирование-взаимодействий-со-страницей)


## Практика работы с логированием

[ссылка на описание домашней работы](./homework.md)

[вверх](#95-логирование-взаимодействий-со-страницей)