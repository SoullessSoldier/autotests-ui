# 9.4 Моки и оптимизация UI автотестов
[назад](../readme.md)


Содержание:
- [Введение в моки](#введение-в-моки)
- [Работаем с моками в Playwright](#работаем-с-моками-в-playwright)


## Введение в моки
Ссылки:
- [Определение моков](https://ru.wikipedia.org/wiki/Mock-объект)
- [Документация по мокам в Playwright](https://playwright.dev/python/docs/mock)


### Что такое моки?

Определение моков можно найти в Википедии. Если говорить простым языком, то моки — это сущности, которые позволяют нам имитировать определенное поведение без реализации полной логики. Это особенно удобно, когда необходимо протестировать функционал, не дожидаясь работы реальных компонентов. Рассмотрим это на примере веб-приложения, которое загружает данные пользователя с сервера. Полный алгоритм работы будет следующим:
1. Браузер обращается к серверу.
2. Сервер ищет пользователя в базе данных.
3. Обрабатывает данные из базы и отправляет их обратно браузеру.
4. Браузер отображает на странице данные пользователя.

Это классический сценарий, где каждое действие последовательно обращается к реальной системе. Теперь рассмотрим, как это будет выглядеть, если вместо сервера будет использоваться мок:
1. Браузер отправляет запрос серверу.
2. Мок на стороне сервера сразу возвращает ответ (например, данные пользователя) без обращения к базе данных и дальнейшей обработки.
3. Браузер отображает данные пользователя.

Таким образом, использование моков позволяет пропустить «тяжелые» или необязательные действия и сразу получить ответ, что значительно упрощает тестирование.

### Зачем нужны моки?
Причины использования моков можно разделить на несколько категорий.

1. **Оптимизация автотестов**
Например, если тестовое приложение загружает множество статических файлов, таких как иконки, изображения, аудио и видео, это может значительно замедлить тесты. Допустим, автотест при каждом запуске подгружает около 50 статических файлов, каждый из которых занимает по 0,2 секунды. В сумме это может занять 5–10 секунд, которые по факту не влияют на функциональность, которую мы тестируем. Использование моков позволяет просто отключить загрузку статических файлов, тем самым заметно ускоряя выполнение автотестов. Это особенно важно при масштабном тестировании, когда такие временные затраты на подгрузку контента могут накапливаться.

2. **Эмуляция нужных состояний**
Моки полезны для тестирования сценариев, в которых требуется конкретное состояние данных, которое сложно создать обычными действиями. Например, нужно протестировать, как система ведет себя при балансе пользователя в $1000. Для достижения этого состояния вручную потребуется проводить сложные операции по пополнению баланса, что может быть неудобно и времязатратно. С помощью моков можно легко задать баланс пользователя на нужном уровне, создав необходимое условие для теста.
Более того, моки помогают с эмуляцией времени. Например, если для теста нужно, чтобы время на клиенте всегда было 15:00 по МСК, сделать это вручную на уровне системы будет проблематично. Моки же позволяют задать это условие, гарантируя нужное поведение.

3. **Подмена данных**
Моки позволяют перехватывать ответы сервера и изменять их для создания разнообразных сценариев. Например, сервер возвращает имя пользователя Username, но для теста нужно проверить, как система работает с другим именем. Мок перехватит и изменит ответ сервера на нужное значение, позволяя не менять серверную логику и не тратить время на создание нового пользователя с требуемыми данными. Подобная подмена данных особенно полезна для тестирования системы с различными входными значениями, когда сервер еще не предоставляет нужные данные или их сложно получить.

Таким образом, моки играют важную роль в тестировании, позволяя оптимизировать процесс, имитировать необходимые состояния и подменять данные. Их основное преимущество — в гибкости, которую они предоставляют для тестов, позволяя легко и быстро получать нужные условия без сложной настройки. Моки экономят время, обеспечивают стабильность тестов и делают тестирование более эффективным и контролируемым.

[вверх](#94-моки-и-оптимизация-ui-автотестов)


## Работаем с моками в Playwright

### Задача
Наша цель — научиться работать с моками в Playwright, отключая подгрузку ненужных для автотестов файлов. В тестируемом приложении UI Course https://nikita-filonov.github.io/qa-automation-engineer-ui-course/#/auth/login немного статических ресурсов, но для примера настроим отключение загрузки статических файлов. На реальных проектах, где таких файлов больше, отключение может существенно ускорить автотесты. Поэтому понимание технологии моков в Playwright важно для оптимизации тестов.

### Выбираем типы файлов для отключения
1. Откройте страницу https://nikita-filonov.github.io/qa-automation-engineer-ui-course/#/auth/login приложения в браузере.
2. Запустите DevTools, чтобы увидеть загружаемые данные (см. скриншот).
3. В списке вы увидите, что подгружаются, например, шрифты формата .woff2. Шрифты не влияют на работу приложения, только на визуализацию, которая в автотестах обычно неважна.

Также, как вы могли заметить, для шрифтов в DevTools указано "(memory cache)", и время подгрузки равно 0 ms. Браузер действительно кэширует некоторые статические файлы, но важно понимать, что для автотестов такой кэш работать не будет. При каждом запуске автотеста создаётся новый экземпляр браузера, и страница открывается с нуля. В результате кэширование файлов не срабатывает, и статические ресурсы загружаются заново, что увеличивает время тестирования.

### Отключаем подгрузку статических файлов
Создадим файл mocks.py в папке /tools/playwright для написания функции mock_static_resources:
```text
.
└── tools/
    └── playwright/
        ├── __init__.py
        ├── pages.py
        └── mocks.py
```

Содержимое *mocks.py*:
```python
from playwright.sync_api import Page, Route


def abort(route: Route):
    # Временно печатаем ссылку на отключаемый ресурс
    print(f'\nAborting url: {route.request.url}')
    route.abort()  # Отменяем загрузку ресурса


def mock_static_resources(page: Page):
    # Отключаем загрузку статических ресурсов
    page.route("**/*.{ico,png,jpg,webp,mp3,mp4,woff,woff2}", abort)
```

Давайте разберем по шагам, что делает данная функция:
- *page.route* — задаёт правила для маршрутов на сервер.
- **Шаблон** ***/*.{ico,png,jpg,webp,mp3,mp4,woff,woff2}* — выбирает файлы с указанными расширениями, чтобы перехватить запросы на изображения, звуки, видео, шрифты. Этот список можно адаптировать под нужды проекта.
- *route.abort()* — отменяет загрузку ресурса, переданного в функцию.

### Применение функции *mock_static_resources*

Применяем функцию mock_static_resources на этапе создания новой страницы. В файле *pages.py* добавим вызов этой функции:
```python
# tools/playwright/pages.py
def initialize_playwright_page(
        playwright: Playwright,
        test_name: str,
        browser_type: Browser,
        storage_state: str | None = None
) -> Page:
    ...
    page = context.new_page()
    mock_static_resources(page)  # Отключаем загрузку статических ресурсов

    yield page
    ...
```

### Проверка работы моков

Теперь можно запустить тест test_wrong_email_or_password_authorization и проверить, что статика не загружается:
```sh
python -m pytest -k "test_wrong_email_or_password_authorization"
```

При запуске, если посмотреть на визуализацию текста, вы заметите, что шрифты стали другими. В консоли будет выведен список заблокированных URL:
```sh
tests/authentication/test_authorization.py::TestAuthorization::test_wrong_email_or_password_authorization[chromium-user.name@gmail.com-password] 
Aborting url: https://fonts.gstatic.com/s/roboto/v32/KFOlCnqEu92Fr1MmEU9fBBc4AMP6lQ.woff2

Aborting url: https://fonts.gstatic.com/s/roboto/v32/KFOmCnqEu92Fr1Mu4mxKKTU1Kg.woff2
```

Это значит, что перехват запросов прошёл успешно, и woff2-шрифты отключены.

### Финальная версия функции *mock_static_resources*

Уберём лишние выводы и упростим функцию:
```python
from playwright.sync_api import Page


def mock_static_resources(page: Page):
    page.route("**/*.{ico,png,jpg,webp,mp3,mp4,woff,woff2}", lambda route: route.abort())
```

### Итоги
На реальных проектах отключение подгрузки статики может снизить время выполнения автотестов на 1-3 секунды на каждый, а при большом числе тестов это даст существенный прирост скорости.

[вверх](#94-моки-и-оптимизация-ui-автотестов)